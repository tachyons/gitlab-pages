include:
  - ci_files/variables.yml
  - ci_files/final_images.yml

variables:
  # Format of the auto-deploy tag for auto-deploy builds.
  # https://gitlab.com/gitlab-org/release/docs/blob/master/general/deploy/auto-deploy.md#auto-deploy-tagging
  AUTO_DEPLOY_TAG_REGEX: '^[0-9]+\.[0-9]+\.[0-9]+\+[a-z0-9]{7,}$'
  AUTO_DEPLOY_BRANCH_REGEX: '^[0-9]+-[0-9]+-auto-deploy-[0-9]+$'
  # Follow the Ruby upgrade guidelines when changing the ruby version
  # link: https://docs.gitlab.com/ee/development/ruby_upgrade.html
  RUBY_VERSION: 2.7.5
  # Suffix to the cache key of gitlab-rails-* where Gem vendor bundles are stored. Enables easy cache busting.
  RAILS_CACHE_SUFFIX: 20220118
  DNF_OPTS: '--disableplugin=subscription-manager'
  DOCKER_VERSION: 20.10.3
  ISSUE_BOT_LABELS_EXTRA: "group::distribution"

stages:
  - prepare
  - prepare:phase-one
  - prepare:phase-two
  - prepare:phase-three
  - prepare:phase-four
  - phase-one
  - phase-two
  - phase-three
  - phase-four
  - phase-five
  - phase-six
  - final-list
  - container-scanning
  - release
  - report

workflow:
  rules:
    # No pipeline on auto-deploy branches as a tag will definitely follow
    - if: '$CI_COMMIT_BRANCH =~ /^[0-9]+-[0-9]+-auto-deploy-[0-9]+$/'
      when: never
    # For all other branches, create a pipeline. We are explicitly specifying
    # this so that this rule gets matched earlier before MR pipelines gets
    # triggered, thus causing two pipelines for a branch push - a regular one
    # and a detached one. If we ever decide not to run pipelines on branch
    # pushes that doesn't cause an MR, we can change the following to
    # $CI_MERGE_REQUEST_IID
    - if: '$CI_COMMIT_BRANCH'
    # No pipeline on tag pushes to com. We build them in dev and sync to com
    - if: '$CI_PROJECT_PATH == "gitlab-org/build/CNG" && $CI_COMMIT_TAG'
      when: never
    # For all other tags, create a pipeline.
    - if: '$CI_COMMIT_TAG'

.if_ee_var: &if_ee_var
  if: '$ee == "true"'

.if_ee_gitlab_version: &if_ee_gitlab_version
  if: '$GITLAB_VERSION =~ /-ee$/'

.if_ce_gitlab_version: &if_ce_gitlab_version
  if: '$GITLAB_VERSION !~ /-ee$/'

.if_ee_tag: &if_ee_tag
  if: '$CI_COMMIT_TAG =~ /^v\d+\.\d+\.\d+(-rc\d+)?-ee$/'

.if_ce_tag: &if_ce_tag
  if: '$CI_COMMIT_TAG =~ /^v\d+\.\d+\.\d+(-rc\d+)?$/'

.if_auto_deploy_tag: &if_auto_deploy_tag
  if: '$CI_COMMIT_TAG =~ /^[0-9]+\.[0-9]+\.[0-9]+\+[a-z0-9]{7,}$/'

.if_ubi_pipeline: &if_ubi_pipeline
  if: '$UBI_PIPELINE == "true" '

.if_ubi_tag: &if_ubi_tag
  if: '$CI_COMMIT_TAG =~ /^v\d+\.\d+\.\d+(-rc\d+)?-ubi8$/'

.if_ubi_branch: &if_ubi_branch
  if: '$CI_COMMIT_REF_NAME =~ /-ubi8$/'

.if_redhat_certification: &if_redhat_certification
  if: '$REDHAT_CERTIFICATION == "true" '

.if_deps_pipeline: &if_deps_pipeline
  if: '$DEPS_PIPELINE'

.if_ce_pipeline: &if_ce_pipeline
  if: '$CE_PIPELINE'

.if_ee_pipeline: &if_ee_pipeline
  if: '$EE_PIPELINE'

.if_custom_pipeline: &if_custom_pipeline
  if: '$CUSTOM_PIPELINE'

.if_gitlab_master: &if_gitlab_master
  if: '$GITLAB_VERSION == "master"'

.if_stable_branch: &if_stable_branch
  if: '$CI_COMMIT_TAG =~ /-stable$/'

.except-deps: &except-deps
  rules:
    - <<: *if_deps_pipeline
      when: never
    - when: always

.only-ee: &only-ee
  rules:
    - <<: *if_deps_pipeline
      when: never
    - <<: *if_ce_pipeline
      when: never
    - <<: *if_custom_pipeline
      when: never
    - <<: *if_ee_pipeline
    - <<: *if_gitlab_master
    - <<: *if_ee_var
    - <<: *if_ee_gitlab_version
    - <<: *if_ee_tag
    - <<: *if_auto_deploy_tag
    - <<: *if_ubi_pipeline
    - <<: *if_ubi_tag

.except-ee: &except-ee
  rules:
    - <<: *if_deps_pipeline
      when: never
    - <<: *if_ee_pipeline
      when: never
    - <<: *if_custom_pipeline
      when: never
    - <<: *if_ee_var
      when: never
    - <<: *if_ee_gitlab_version
      when: never
    - <<: *if_ee_tag
      when: never
    - <<: *if_auto_deploy_tag
      when: never
    - <<: *if_ubi_pipeline
      when: never
    - <<: *if_ubi_tag
      when: never
    - <<: *if_ubi_branch
      when: never
    - <<: *if_ce_pipeline
    - <<: *if_gitlab_master
    - <<: *if_ce_gitlab_version
    - <<: *if_ce_tag

.only-ubi: &only-ubi
  rules:
    - <<: *if_deps_pipeline
      when: never
    - <<: *if_ubi_pipeline
    - <<: *if_ubi_tag
    - <<: *if_ubi_branch

.job-base: &job-base
  image: "registry.gitlab.com/gitlab-org/gitlab-omnibus-builder/ruby_docker:3.1.0"
  services:
  - docker:${DOCKER_VERSION}-dind
  needs: []
  retry: 1
  before_script:
    # Always compile assets for auto-deploy builds,
    # this is done for auto-deploy builds
    # so that we do not have to wait for the compile assets job
    # in the gitlab-ee pipeline.
    - |
      if [[ $CI_COMMIT_TAG =~ $AUTO_DEPLOY_TAG_REGEX ]]; then
        echo "Setting COMPILE_ASSETS env variable for auto-deploy"
        export COMPILE_ASSETS=true
      fi
    - mkdir -p artifacts/images artifacts/container_versions artifacts/final
    - source build-scripts/build.sh
    - if [[ "${CI_COMMIT_TAG}" == *-ubi8 || "${CI_COMMIT_REF_NAME}" == *-ubi8 ]]; then
    -   export UBI_PIPELINE="true"
    - fi
    - if [ "${UBI_PIPELINE}" = "true" ]; then
    -   export DOCKERFILE_EXT='.ubi8'
    -   export IMAGE_TAG_EXT='-ubi8'
    -   use_assets
    - fi
    - export {CONTAINER_VERSION,BASE_VERSION}=$(get_version gitlab-ruby)
    - export TARGET_VERSION=$(get_target_version)
    - docker login -u "$CI_DEPENDENCY_PROXY_USER" -p "$CI_DEPENDENCY_PROXY_PASSWORD" "$CI_DEPENDENCY_PROXY_SERVER"
    - docker login -u gitlab-ci-token -p "$CI_JOB_TOKEN" "$CI_REGISTRY"
  artifacts:
    paths:
      - artifacts/

.build-job-base: &build-job-base
  image: "registry.gitlab.com/gitlab-org/gitlab-omnibus-builder/ruby_docker:3.1.0"
  services:
  - docker:${DOCKER_VERSION}-dind
  retry: 1
  before_script:
    # Always compile assets for auto-deploy builds,
    # this is done for auto-deploy builds
    # so that we do not have to wait for the compile assets job
    # in the gitlab-ee pipeline.
    - |
      if [[ $CI_COMMIT_TAG =~ $AUTO_DEPLOY_TAG_REGEX ]]; then
        echo "Setting COMPILE_ASSETS env variable for auto-deploy"
        export COMPILE_ASSETS=true
      fi
    - mkdir -p artifacts/images artifacts/container_versions
    - source build-scripts/build.sh
    - if [[ "${CI_COMMIT_TAG}" == *-ubi8 || "${CI_COMMIT_REF_NAME}" == *-ubi8 ]]; then
    -   export UBI_PIPELINE="true"
    - fi
    - export DOCKERFILE_EXT='.build.ubi8'
    - export IMAGE_TAG_EXT='-build-ubi8'
    - export UBI_BUILD_IMAGE='true'
    - export TARGET_VERSION=$(get_target_version)
    - export CONTAINER_VERSION="${TARGET_VERSION}"
    - BUILD_IMAGE_VERSION="$(get_version gitlab-ubi-builder)"
    - export BUILD_IMAGE="${CI_REGISTRY_IMAGE}/gitlab-ubi-builder:${BUILD_IMAGE_VERSION}-ubi8"
    - docker login -u "$CI_DEPENDENCY_PROXY_USER" -p "$CI_DEPENDENCY_PROXY_PASSWORD" "$CI_DEPENDENCY_PROXY_SERVER"
    - docker login -u gitlab-ci-token -p "$CI_JOB_TOKEN" "$CI_REGISTRY"
  artifacts:
    paths:
      - artifacts/
  <<: *only-ubi
  needs:
    - gitlab-ubi-builder

dependency_update:
  image: registry.gitlab.com/gitlab-org/gitlab-omnibus-builder/ruby_docker:3.1.0
  stage: prepare
  variables:
    INSTALL_SHA256: "c95a33432192688a08d935fd5f563fce4110610a51281f887ae88db208b720ba"
  script:
    - curl --retry 6 -fO https://deps.app/install.sh
    - echo "${INSTALL_SHA256}  install.sh" | sha256sum --check
    - cat install.sh | bash -s -- -b $HOME/bin
    # Remove the install.sh script otherwise deps gets upset about pending changes when it goes to create new branches
    - rm install.sh
    - $HOME/bin/deps ci
  rules:
    - <<: *if_deps_pipeline

gitlab-ubi-builder:
  <<: *build-job-base
  stage: prepare
  script:
    - export DOCKERFILE_EXT='.ubi8'
    - export IMAGE_TAG_EXT='-ubi8'
    - export UBI_BUILD_IMAGE='false'
    - mkdir -p artifacts/images
    - build_if_needed
  needs: []

danger-review:
  image: registry.gitlab.com/gitlab-org/gitlab-build-images:danger
  stage: prepare
  cache: {}
  rules:
    # source not a push, this is not a tag, not the default or stable branches
    - if: '$CI_PIPELINE_SOURCE != "push" || $CI_COMMIT_TAG || $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH || $CI_COMMIT_BRANCH =~ /^[0-9]+-[0-9]+-stable$/'
      when: never
    # unless above, if API token defined, run Danger
    - if: '$DANGER_GITLAB_API_TOKEN'
  script:
    - danger --fail-on-errors=true

build:gitlab-ruby:
  <<: *build-job-base
  stage: prepare:phase-one
  script:
    - export CONTAINER_VERSION=($(echo -n "$TARGET_VERSION${RUBY_VERSION}" | sha1sum))
    - build_if_needed --build-arg "RUBY_VERSION=$RUBY_VERSION"
    - copy_assets
    - echo -n "${CONTAINER_VERSION}" > artifacts/container_versions/build_gitlab-ruby_tag.txt

gitlab-ruby:
  <<: *job-base
  <<: *except-deps
  stage: phase-one
  needs:
    - job: build:gitlab-ruby
      optional: true
  script:
    - export CONTAINER_VERSION=($(echo -n "$TARGET_VERSION${RUBY_VERSION}" | sha1sum))
    - build_if_needed --build-arg "RUBY_VERSION=$RUBY_VERSION"
    - push_tags
    - echo -n "${CONTAINER_VERSION}" > artifacts/container_versions/gitlab-ruby_tag.txt

build:gitlab-logger:
  <<: *build-job-base
  stage: prepare:phase-two
  script:
    - import_assets artifacts/ubi/gitlab-go.tar.gz
    - go_version=$(cat artifacts/container_versions/build_gitlab-go_tag.txt)
    - export CONTAINER_VERSION=($(echo -n "$go_version$TARGET_VERSION$GITLAB_LOGGER_VERSION$CI_PIPELINE_CREATED_AT" | sha1sum))
    - build_if_needed --build-arg "GITLAB_LOGGER_VERSION=$GITLAB_LOGGER_VERSION"
                      --build-arg "GITLAB_LOGGER_SHA256=${GITLAB_LOGGER_SHA256}"
    - copy_assets
    - echo -n "${TARGET_VERSION}" > artifacts/container_versions/build_gitlab-logger_tag.txt
  needs:
    - build:gitlab-go

gitlab-logger:
  <<: *job-base
  <<: *except-deps
  stage: phase-three
  script:
    - go_version=$(cat artifacts/container_versions/gitlab-go_tag.txt)
    - export CONTAINER_VERSION=($(echo -n "$go_version$TARGET_VERSION$GITLAB_LOGGER_VERSION$CI_PIPELINE_CREATED_AT" | sha1sum))
    - build_if_needed --build-arg "GITLAB_LOGGER_VERSION=$GITLAB_LOGGER_VERSION"
                      --build-arg "GO_TAG=${go_version}${IMAGE_TAG_EXT}"
                      --build-arg "GITLAB_LOGGER_SHA256=${GITLAB_LOGGER_SHA256}"
    - push_tags
    - push_tags $GITLAB_LOGGER_VERSION${IMAGE_TAG_EXT}
    - echo -n "${TARGET_VERSION}" > artifacts/container_versions/gitlab-logger_tag.txt
  needs:
    - gitlab-go

build:gitlab-pages:
  <<: *build-job-base
  stage: prepare:phase-two
  script:
    - import_assets artifacts/ubi/gitlab-go.tar.gz
    - export CONTAINER_VERSION=($(echo -n "$TARGET_VERSION$GITLAB_PAGES_VERSION$CI_PIPELINE_CREATED_AT" | sha1sum))
    - build_if_needed --build-arg "VERSION=${GITLAB_PAGES_VERSION}"
                      --build-arg "NAMESPACE=${GITLAB_NAMESPACE}"
                      --build-arg "API_URL=${CI_API_V4_URL}"
                      --build-arg "API_TOKEN=${FETCH_DEV_ARTIFACTS_PAT}"
    - copy_assets
  needs:
    - build:gitlab-go

gitlab-pages:
  <<: *job-base
  <<: *except-deps
  stage: phase-four
  script:
    - import_assets artifacts/ubi/gitlab-gomplate.tar.gz
    - ruby_version=$(cat artifacts/container_versions/gitlab-ruby_tag.txt)
    - go_version=$(cat artifacts/container_versions/gitlab-go_tag.txt)
    - gomplate_version=$(cat artifacts/container_versions/gitlab-gomplate_tag.txt)
    - export CONTAINER_VERSION=($(echo -n "$go_version$gomplate_version$TARGET_VERSION$GITLAB_VERSION$CI_PIPELINE_CREATED_AT" | sha1sum))
    - build_if_needed --build-arg "GITLAB_PAGES_VERSION=$GITLAB_PAGES_VERSION"
                      --build-arg "GO_TAG=${go_version}${IMAGE_TAG_EXT}"
                      --build-arg "GOMPLATE_TAG=${gomplate_version}${IMAGE_TAG_EXT}"
                      --build-arg "FETCH_ARTIFACTS_PAT=${FETCH_DEV_ARTIFACTS_PAT}"
                      --build-arg "DEPENDENCY_PROXY=${DEPENDENCY_PROXY}"
                      --build-arg "RUBY_IMAGE=${CI_REGISTRY_IMAGE}/gitlab-ruby:$ruby_version${IMAGE_TAG_EXT}"
                      --build-arg "CI_API_V4_URL=${CI_API_V4_URL}"
                      --build-arg "GITLAB_NAMESPACE=${GITLAB_NAMESPACE}"
    - push_tags
    - push_tags $GITLAB_PAGES_VERSION${IMAGE_TAG_EXT}
    - echo -n "${CONTAINER_VERSION}" > artifacts/container_versions/gitlab-pages_tag.txt
  needs:
    - gitlab-go
    - gitlab-gomplate
    - gitlab-ruby
    - job: build:gitlab-gomplate
      optional: true
    - job: build:gitlab-pages
      optional: true

build:gitlab-graphicsmagick:
  <<: *build-job-base
  stage: prepare:phase-one
  script:
    - export CONTAINER_VERSION=($(echo -n "$TARGET_VERSION${GM_VERSION}" | sha1sum))
    - build_if_needed --build-arg "GM_VERSION=$GM_VERSION"
    - copy_assets

gitlab-graphicsmagick:
  <<: *job-base
  <<: *except-deps
  stage: phase-one
  script:
    - export CONTAINER_VERSION=($(echo -n "$TARGET_VERSION${GM_VERSION}" | sha1sum))
    - export GM_VERSION_MINOR=$(expr match $GM_VERSION '\(^[0-9]\+.[0-9]\+\)')
    - build_if_needed --build-arg "GM_VERSION=$GM_VERSION" --build-arg "GM_VERSION_MINOR=$GM_VERSION_MINOR"
    - push_tags
    - push_tags $GM_VERSION${IMAGE_TAG_EXT}
    - echo -n "${CONTAINER_VERSION}" > artifacts/container_versions/gitlab-graphicsmagick_tag.txt

build:gitlab-gomplate:
  <<: *build-job-base
  stage: prepare:phase-one
  script:
    - export CONTAINER_VERSION=($(echo -n "$TARGET_VERSION${GOMPLATE_VERSION}" | sha1sum))
    - build_if_needed --build-arg "GOMPLATE_VERSION=$GOMPLATE_VERSION"
    - copy_assets

gitlab-gomplate:
  <<: *job-base
  <<: *except-deps
  stage: phase-one
  needs:
    - job: build:gitlab-gomplate
      optional: true
  script:
    - export CONTAINER_VERSION=($(echo -n "$TARGET_VERSION${GOMPLATE_VERSION}" | sha1sum))
    - build_if_needed --build-arg "GOMPLATE_VERSION=$GOMPLATE_VERSION"
    - push_tags
    - push_tags $GOMPLATE_VERSION${IMAGE_TAG_EXT}
    - echo -n "${CONTAINER_VERSION}" > artifacts/container_versions/gitlab-gomplate_tag.txt

build:postgresql:
  <<: *build-job-base
  stage: prepare:phase-one
  script:
    - export CONTAINER_VERSION=($(echo -n "$TARGET_VERSION${PG_VERSION}" | sha1sum))
    - build_if_needed --build-arg "PG_VERSION=$PG_VERSION"
    - copy_assets

postgresql:
  <<: *job-base
  <<: *except-deps
  stage: phase-one
  needs:
    - job: build:postgresql
      optional: true
  script:
    - export CONTAINER_VERSION=($(echo -n "$TARGET_VERSION$PG_VERSION" | sha1sum))
    - build_if_needed --build-arg "PG_VERSION=$PG_VERSION"
                      --build-arg "FROM_IMAGE=${DEPENDENCY_PROXY}debian"
    - push_tags
    - push_tags $PG_VERSION${IMAGE_TAG_EXT}
    - echo -n "${CONTAINER_VERSION}" > artifacts/container_versions/postgresql_tag.txt

build:cfssl-self-sign:
  <<: *build-job-base
  stage: prepare:phase-one
  script:
    - export CONTAINER_VERSION=($(echo -n "$TARGET_VERSION${CFSSL_VERSION}" | sha1sum))
    - build_if_needed --build-arg "CFSSL_VERSION=$CFSSL_VERSION"
                      --build-arg "CFSSL_CHECKSUM_SHA256=$CFSSL_CHECKSUM_SHA256"
    - copy_assets

cfssl-self-sign:
  <<: *job-base
  <<: *except-deps
  stage: phase-one
  script:
    - export DOCKERFILE_EXT=
    - export CONTAINER_VERSION=($(echo -n "$TARGET_VERSION$CFSSL_VERSION" | sha1sum))
    - build_if_needed --build-arg "CFSSL_VERSION=$CFSSL_VERSION"
                      --build-arg "CFSSL_CHECKSUM_SHA256=$CFSSL_CHECKSUM_SHA256"
                      --build-arg "ALPINE_VERSION=$ALPINE_VERSION"
                      --build-arg "FROM_IMAGE=${DEPENDENCY_PROXY}alpine"
    - push_tags
    - push_tags "$CFSSL_VERSION"

build:kubectl:
  <<: *build-job-base
  stage: prepare:phase-one
  script:
    - export CONTAINER_VERSION=($(echo -n "$TARGET_VERSION${KUBECTL_VERSION}" | sha1sum))
    - build_if_needed --build-arg "KUBECTL_VERSION=${KUBECTL_VERSION}"
    - copy_assets

kubectl:
  <<: *job-base
  <<: *except-deps
  stage: phase-one
  needs:
    - job: build:kubectl
      optional: true
  script:
    - export CONTAINER_VERSION=($(echo -n "$TARGET_VERSION${KUBECTL_VERSION}" | sha1sum))
    - build_if_needed --build-arg "KUBECTL_VERSION=${KUBECTL_VERSION}"
                      --build-arg "FROM_IMAGE=${DEPENDENCY_PROXY}debian"
    - push_tags
    - push_tags $KUBECTL_VERSION${IMAGE_TAG_EXT}

alpine-certificates:
  <<: *job-base
  <<: *except-deps
  stage: phase-one
  script:
    - export CONTAINER_VERSION=($(echo -n "$TARGET_VERSION$CA_PKG_VERSION" | sha1sum))
    - build_if_needed --build-arg "ALPINE_VERSION=${ALPINE_VERSION}"
                      --build-arg "CA_PKG_VERSION=${CA_PKG_VERSION}"
                      --build-arg "FROM_IMAGE=${DEPENDENCY_PROXY}alpine"
    - push_tags
    - push_tags ${CA_PKG_VERSION}${IMAGE_TAG_EXT}

build:gitlab-python:
  <<: *build-job-base
  stage: prepare:phase-one
  script:
    - export CONTAINER_VERSION=($(echo -n "$TARGET_VERSION$PYTHON_VERSION" | sha1sum))
    - build_if_needed --build-arg "PYTHON_VERSION=${PYTHON_VERSION}"
    - copy_assets

gitlab-python:
  <<: *job-base
  <<: *except-deps
  stage: phase-one
  needs:
    - job: build:gitlab-python
      optional: true
  script:
    - export CONTAINER_VERSION=($(echo -n "$TARGET_VERSION$PYTHON_VERSION" | sha1sum))
    - build_if_needed --build-arg "PYTHON_VERSION=${PYTHON_VERSION}"
                      --build-arg "FROM_IMAGE=${DEPENDENCY_PROXY}debian"
    - push_tags
    - push_tags ${PYTHON_VERSION}${IMAGE_TAG_EXT}
    - echo -n "${CONTAINER_VERSION}" > artifacts/container_versions/gitlab-python_tag.txt

build:gitlab-go:
  <<: *build-job-base
  stage: prepare:phase-one
  script:
    - export CONTAINER_VERSION=($(echo -n "$BASE_VERSION$TARGET_VERSION$GO_VERSION" | sha1sum))
    - build_if_needed --build-arg "GO_VERSION=$GO_VERSION"
    - copy_assets
    - echo -n "${CONTAINER_VERSION}" > artifacts/container_versions/build_gitlab-go_tag.txt

gitlab-go:
  <<: *job-base
  <<: *except-deps
  stage: phase-two
  script:
    - ruby_version=$(cat artifacts/container_versions/gitlab-ruby_tag.txt)
    - export CONTAINER_VERSION=($(echo -n "$BASE_VERSION$TARGET_VERSION$ruby_version$GO_VERSION" | sha1sum))
    - build_if_needed --build-arg "GO_VERSION=$GO_VERSION"
                      --build-arg "FROM_IMAGE=$CI_REGISTRY_IMAGE/gitlab-ruby"
                      --build-arg "TAG=$ruby_version${IMAGE_TAG_EXT}"
    - push_tags
    - echo -n "${CONTAINER_VERSION}" > artifacts/container_versions/gitlab-go_tag.txt
  needs:
    - gitlab-ruby

build:gitlab-rails-ee:
  <<: *build-job-base
  stage: prepare:phase-three
  needs:
    - build:gitlab-ruby
    - build:postgresql
    - build:gitlab-elasticsearch-indexer
    - build:gitlab-graphicsmagick
  script:
    - import_assets artifacts/ubi/{gitlab-ruby,postgresql,gitlab-elasticsearch-indexer,gitlab-graphicsmagick}.tar.gz
    - ruby_version=$(cat artifacts/container_versions/build_gitlab-ruby_tag.txt)
    - export CONTAINER_VERSION=($(echo -n "$ruby_version$TARGET_VERSION$GITLAB_VERSION$CI_PIPELINE_CREATED_AT" | sha1sum))
    - export ASSETS_IMAGE="${ASSETS_IMAGE_REGISTRY_PREFIX}/${EE_PROJECT}/${ASSETS_IMAGE_PREFIX}-ee:${GITLAB_ASSETS_TAG}"
    - fetch_assets
    - build_if_needed --build-arg "NAMESPACE=${GITLAB_NAMESPACE}"
                      --build-arg "PROJECT=${EE_PROJECT}"
                      --build-arg "VERSION=${GITLAB_VERSION}"
                      --build-arg "API_URL=${CI_API_V4_URL}"
                      --build-arg "API_TOKEN=${FETCH_DEV_ARTIFACTS_PAT}"
                      --build-arg "ASSETS_IMAGE=${ASSETS_IMAGE}"
    - copy_assets

gitlab-rails-ee:
  <<: *job-base
  <<: *only-ee
  stage: phase-five
  needs:
    - postgresql
    - gitlab-graphicsmagick
    - gitlab-ruby
    - gitlab-elasticsearch-indexer
    - job: build:gitlab-rails-ee
      optional: true
    - gitlab-gomplate
    - job: build:gitlab-gomplate
      optional: true
  variables:
    RAILS_EE: "true"
  script:
    - import_assets artifacts/ubi/gitlab-gomplate.tar.gz
    - go_version=$(cat artifacts/container_versions/gitlab-go_tag.txt)
    - ruby_version=$(cat artifacts/container_versions/gitlab-ruby_tag.txt)
    - export FORCE_IMAGE_BUILDS="${FORCE_IMAGE_BUILDS-${FORCE_RAILS_IMAGE_BUILDS-false}}"
    - export CONTAINER_VERSION=($(echo -n "$ruby_version$TARGET_VERSION$GITLAB_VERSION$CI_PIPELINE_CREATED_AT" | sha1sum))
    - if [ ! "$UBI_PIPELINE" = "true" ]; then
    -   export BASE_IMAGE="$CI_REGISTRY_IMAGE/gitlab-ruby:$ruby_version${IMAGE_TAG_EXT}"
    - fi
    - pg_version=$(cat artifacts/container_versions/postgresql_tag.txt)
    - pg_image="${CI_REGISTRY_IMAGE}/postgresql:${pg_version}"
    - gei_dir_version=$(get_version gitlab-elasticsearch-indexer)
    - gei_version=($(echo -n "$GITLAB_ELASTICSEARCH_INDEXER_VERSION$go_version$gei_dir_version" | sha1sum))
    - gei_image="${CI_REGISTRY_IMAGE}/gitlab-elasticsearch-indexer:${gei_version}${IMAGE_TAG_EXT}"
    - gm_version=$(cat artifacts/container_versions/gitlab-graphicsmagick_tag.txt)
    - gm_image="${CI_REGISTRY_IMAGE}/gitlab-graphicsmagick:${gm_version}"
    - gomplate_version=$(cat artifacts/container_versions/gitlab-gomplate_tag.txt)
    - docker pull $pg_image > /dev/null || true
    - export ASSETS_IMAGE="${ASSETS_IMAGE_REGISTRY_PREFIX}/${EE_PROJECT}/${ASSETS_IMAGE_PREFIX}-ee:${GITLAB_ASSETS_TAG}"
    - fetch_assets
    - build_if_needed --build-arg "GITLAB_VERSION=${GITLAB_VERSION}"
                      --build-arg "GITLAB_NAMESPACE=${GITLAB_NAMESPACE}"
                      --build-arg "GITLAB_PROJECT=${EE_PROJECT}"
                      --build-arg "FETCH_ARTIFACTS_PAT=${FETCH_DEV_ARTIFACTS_PAT}"
                      --build-arg "CI_API_V4_URL=${CI_API_V4_URL}"
                      --build-arg "CACHE_BUSTER=$GITLAB_VERSION$(date -uI)"
                      --build-arg "TAG=$ruby_version${IMAGE_TAG_EXT}"
                      --build-arg "PG_IMAGE=$pg_image"
                      --build-arg "GEI_IMAGE=${gei_image}"
                      --build-arg "ASSETS_IMAGE=${ASSETS_IMAGE}"
                      --build-arg "RUBY_IMAGE=${CI_REGISTRY_IMAGE}/gitlab-ruby:$ruby_version${IMAGE_TAG_EXT}"
                      --build-arg "GM_IMAGE=${gm_image}"
                      --build-arg "GOMPLATE_TAG=${gomplate_version}${IMAGE_TAG_EXT}"
    - push_tags $GITLAB_REF_SLUG${IMAGE_TAG_EXT}
    - if [ ! "$UBI_PIPELINE" = "true" ]; then
    -   image_name=$(cat artifacts/images/$CI_JOB_NAME.txt)
    -   container_id=$(docker create "${CI_REGISTRY_IMAGE}/${image_name}")
    -   rm -rf ${CI_PROJECT_DIR}/gitlab-rails/vendor
    -   mkdir -p ${CI_PROJECT_DIR}/gitlab-rails/vendor
    -   docker cp $container_id:/srv/gitlab/vendor/bundle ${CI_PROJECT_DIR}/gitlab-rails/vendor
    -   docker rm -v $container_id
    - fi
    - echo -n "${CONTAINER_VERSION}" > artifacts/container_versions/gitlab-rails-ee_tag.txt
  cache:
    key: "$CI_JOB_NAME-gitlab-rails-vendor-bundle-$RAILS_CACHE_SUFFIX"
    paths:
      - gitlab-rails/vendor/bundle

gitlab-rails-ce:
  <<: *job-base
  <<: *except-ee
  stage: phase-five
  needs:
    - gitlab-ruby
    - postgresql
    - gitlab-graphicsmagick
    - gitlab-gomplate
    - job: build:gitlab-gomplate
      optional: true
  script:
    - import_assets artifacts/ubi/gitlab-gomplate.tar.gz
    - ruby_version=$(cat artifacts/container_versions/gitlab-ruby_tag.txt)
    - export FORCE_IMAGE_BUILDS="${FORCE_IMAGE_BUILDS-${FORCE_RAILS_IMAGE_BUILDS-false}}"
    - export CONTAINER_VERSION=($(echo -n "$ruby_version$TARGET_VERSION$GITLAB_VERSION$CI_PIPELINE_CREATED_AT" | sha1sum))
    - export BASE_IMAGE="$CI_REGISTRY_IMAGE/gitlab-ruby:$ruby_version"
    - pg_version=$(cat artifacts/container_versions/postgresql_tag.txt)
    - pg_image="${CI_REGISTRY_IMAGE}/postgresql:${pg_version}"
    - gm_version=$(cat artifacts/container_versions/gitlab-graphicsmagick_tag.txt)
    - gm_image="${CI_REGISTRY_IMAGE}/gitlab-graphicsmagick:${gm_version}"
    - gomplate_version=$(cat artifacts/container_versions/gitlab-gomplate_tag.txt)
    - docker pull $pg_image > /dev/null || true
    - export ASSETS_IMAGE="${ASSETS_IMAGE_REGISTRY_PREFIX}/${CE_PROJECT}/${ASSETS_IMAGE_PREFIX}-ce:${GITLAB_ASSETS_TAG}"
    - fetch_assets
    - build_if_needed --build-arg "GITLAB_VERSION=${GITLAB_VERSION}"
                      --build-arg "GITLAB_NAMESPACE=${GITLAB_NAMESPACE}"
                      --build-arg "GITLAB_PROJECT=${CE_PROJECT}"
                      --build-arg "FETCH_ARTIFACTS_PAT=${FETCH_DEV_ARTIFACTS_PAT}"
                      --build-arg "CI_API_V4_URL=${CI_API_V4_URL}"
                      --build-arg "CACHE_BUSTER=$GITLAB_VERSION$(date -uI)"
                      --build-arg "TAG=$ruby_version"
                      --build-arg "PG_IMAGE=$pg_image"
                      --build-arg "ASSETS_IMAGE=${ASSETS_IMAGE}"
                      --build-arg "GM_IMAGE=${gm_image}"
                      --build-arg "GOMPLATE_TAG=${gomplate_version}${IMAGE_TAG_EXT}"
    - push_tags $GITLAB_REF_SLUG
    - if [ ! "$UBI_PIPELINE" = "true" ]; then
    -   image_name=$(cat artifacts/images/$CI_JOB_NAME.txt)
    -   container_id=$(docker create "${CI_REGISTRY_IMAGE}/${image_name}")
    -   rm -rf ${CI_PROJECT_DIR}/gitlab-rails/vendor
    -   mkdir -p ${CI_PROJECT_DIR}/gitlab-rails/vendor
    -   docker cp $container_id:/srv/gitlab/vendor/bundle ${CI_PROJECT_DIR}/gitlab-rails/vendor
    -   docker rm -v $container_id
    - fi
    - echo -n "${CONTAINER_VERSION}" > artifacts/container_versions/gitlab-rails-ce_tag.txt
  cache:
    key: "$CI_JOB_NAME-gitlab-rails-vendor-bundle-$RAILS_CACHE_SUFFIX"
    paths:
      - gitlab-rails/vendor/bundle

build:gitlab-toolbox-ee:
  <<: *build-job-base
  stage: prepare:phase-three
  needs:
    - build:gitlab-python
    - build:gitaly
    - build:gitlab-ruby
  script:
    - import_assets artifacts/ubi/gitlab-python.tar.gz
    - import_assets artifacts/ubi/gitaly.tar.gz
    - ruby_version=$(cat artifacts/container_versions/build_gitlab-ruby_tag.txt)
    - rails_container=($(echo -n "$ruby_version$TARGET_VERSION$GITLAB_VERSION$CI_PIPELINE_CREATED_AT" | sha1sum))
    - export CONTAINER_VERSION=($(echo -n "$rails_container$TARGET_VERSION" | sha1sum))
    - build_if_needed --build-arg "S3CMD_VERSION=$S3CMD_VERSION"
    - copy_assets

gitlab-toolbox-ee:
  <<: *job-base
  <<: *only-ee
  stage: phase-six
  script:
    - import_assets artifacts/ubi/gitlab-python.tar.gz
    - ruby_version=$(cat artifacts/container_versions/gitlab-ruby_tag.txt)
    - rails_version=$(get_version gitlab-rails)
    - rails_container=$(cat artifacts/container_versions/gitlab-rails-ee_tag.txt)
    - gitaly_container=$(cat artifacts/container_versions/gitaly_tag.txt)
    - python_version=$(cat artifacts/container_versions/gitlab-python_tag.txt)
    - export FORCE_IMAGE_BUILDS="${FORCE_IMAGE_BUILDS-${FORCE_RAILS_IMAGE_BUILDS-false}}"
    - export CONTAINER_VERSION=($(echo -n "$rails_container$TARGET_VERSION" | sha1sum))
    - if [ ! "$UBI_PIPELINE" = "true" ]; then
    -   export BASE_IMAGE="$CI_REGISTRY_IMAGE/gitlab-rails-ee:$rails_container${IMAGE_TAG_EXT}"
    - fi
    - build_if_needed --build-arg "FROM_IMAGE=$CI_REGISTRY_IMAGE/gitlab-rails-ee"
                      --build-arg "TAG=$rails_container${IMAGE_TAG_EXT}"
                      --build-arg "PYTHON_TAG=${python_version}${IMAGE_TAG_EXT}"
                      --build-arg "S3CMD_VERSION=$S3CMD_VERSION"
                      --build-arg "GITLAB_VERSION=${GITLAB_VERSION}"
                      --build-arg "RAILS_IMAGE=$CI_REGISTRY_IMAGE/gitlab-rails-ee:$rails_container${IMAGE_TAG_EXT}"
                      --build-arg "GITALY_IMAGE=$CI_REGISTRY_IMAGE/gitaly:$gitaly_container${IMAGE_TAG_EXT}"
    - push_tags $GITLAB_REF_SLUG${IMAGE_TAG_EXT}
    - push_tags $GITLAB_REF_SLUG${IMAGE_TAG_EXT} ${CI_JOB_NAME/toolbox/task-runner}
  needs:
    - gitlab-rails-ee
    - gitlab-python
    - gitaly
    - job: build:gitlab-toolbox-ee
      optional: true
    - job: build:gitlab-python
      optional: true

gitlab-toolbox-ce:
  <<: *job-base
  <<: *except-ee
  stage: phase-six
  script:
    - ruby_version=$(cat artifacts/container_versions/gitlab-ruby_tag.txt)
    - rails_version=$(get_version gitlab-rails)
    - rails_container=$(cat artifacts/container_versions/gitlab-rails-ce_tag.txt)
    - gitaly_container=$(cat artifacts/container_versions/gitaly_tag.txt)
    - python_version=$(cat artifacts/container_versions/gitlab-python_tag.txt)
    - export FORCE_IMAGE_BUILDS="${FORCE_IMAGE_BUILDS-${FORCE_RAILS_IMAGE_BUILDS-false}}"
    - export CONTAINER_VERSION=($(echo -n "$rails_container$TARGET_VERSION" | sha1sum))
    - export BASE_IMAGE="$CI_REGISTRY_IMAGE/gitlab-rails-ce:$rails_container"
    - build_if_needed --build-arg "FROM_IMAGE=$CI_REGISTRY_IMAGE/gitlab-rails-ce"
                      --build-arg "TAG=$rails_container"
                      --build-arg "PYTHON_TAG=${python_version}"
                      --build-arg "S3CMD_VERSION=$S3CMD_VERSION"
                      --build-arg "GITALY_IMAGE=$CI_REGISTRY_IMAGE/gitaly:$gitaly_container${IMAGE_TAG_EXT}"
    - push_tags $GITLAB_REF_SLUG
    - push_tags $GITLAB_REF_SLUG ${CI_JOB_NAME/toolbox/task-runner}
  needs:
    - gitlab-rails-ce
    - gitlab-python
    - gitaly

gitlab-geo-logcursor:
  <<: *job-base
  <<: *only-ee
  stage: phase-six
  script:
    - ruby_version=$(cat artifacts/container_versions/gitlab-ruby_tag.txt)
    - rails_version=$(get_version gitlab-rails)
    - rails_container=$(cat artifacts/container_versions/gitlab-rails-ee_tag.txt)
    - export FORCE_IMAGE_BUILDS="${FORCE_IMAGE_BUILDS-${FORCE_RAILS_IMAGE_BUILDS-false}}"
    - export CONTAINER_VERSION=($(echo -n "$rails_container$TARGET_VERSION" | sha1sum))
    - export BASE_IMAGE="$CI_REGISTRY_IMAGE/gitlab-rails-ee:$rails_container${IMAGE_TAG_EXT}"
    - build_if_needed --build-arg "FROM_IMAGE=$CI_REGISTRY_IMAGE/gitlab-rails-ee"
                      --build-arg "TAG=$rails_container${IMAGE_TAG_EXT}"
                      --build-arg "GITLAB_VERSION=${GITLAB_VERSION}"
                      --build-arg "RAILS_IMAGE=$CI_REGISTRY_IMAGE/gitlab-rails-ee:$rails_container${IMAGE_TAG_EXT}"
    - push_tags $GITLAB_REF_SLUG${IMAGE_TAG_EXT}
  needs:
    - gitlab-rails-ee

build:gitlab-webservice-ee:
  <<: *build-job-base
  stage: prepare:phase-two
  needs:
    - build:gitlab-python
    - build:gitlab-ruby
  script:
    - import_assets artifacts/ubi/gitlab-python.tar.gz
    - ruby_version=$(cat artifacts/container_versions/build_gitlab-ruby_tag.txt)
    - rails_container=($(echo -n "$ruby_version$TARGET_VERSION$GITLAB_VERSION$CI_PIPELINE_CREATED_AT" | sha1sum))
    - export CONTAINER_VERSION=($(echo -n "$rails_container$TARGET_VERSION" | sha1sum))
    - build_if_needed
    - copy_assets

gitlab-webservice-ee:
  <<: *job-base
  <<: *only-ee
  stage: phase-six
  script:
    - import_assets artifacts/ubi/gitlab-python.tar.gz
    - import_assets artifacts/ubi/gitlab-logger.tar.gz
    - ruby_version=$(cat artifacts/container_versions/gitlab-ruby_tag.txt)
    - go_version=$(cat artifacts/container_versions/gitlab-go_tag.txt)
    - logger_target_version=$(cat artifacts/container_versions/gitlab-logger_tag.txt)
    - rails_version=$(get_version gitlab-rails)
    - rails_container=$(cat artifacts/container_versions/gitlab-rails-ee_tag.txt)
    - python_version=$(cat artifacts/container_versions/gitlab-python_tag.txt)
    - export FORCE_IMAGE_BUILDS="${FORCE_IMAGE_BUILDS-${FORCE_RAILS_IMAGE_BUILDS-false}}"
    - export GITLAB_LOGGER_VERSION=($(echo -n "$go_version$logger_target_version$GITLAB_LOGGER_VERSION$CI_PIPELINE_CREATED_AT" | sha1sum))
    - export CONTAINER_VERSION=($(echo -n "$rails_container$TARGET_VERSION" | sha1sum))
    - if [ ! "$UBI_PIPELINE" = "true" ]; then
    -   export BASE_IMAGE="$CI_REGISTRY_IMAGE/gitlab-rails-ee:$rails_container${IMAGE_TAG_EXT}"
    - fi
    - build_if_needed --build-arg "FROM_IMAGE=$CI_REGISTRY_IMAGE/gitlab-rails-ee"
                      --build-arg "TAG=$rails_container${IMAGE_TAG_EXT}"
                      --build-arg "PYTHON_TAG=${python_version}${IMAGE_TAG_EXT}"
                      --build-arg "GITLAB_VERSION=${GITLAB_VERSION}"
                      --build-arg "RAILS_IMAGE=$CI_REGISTRY_IMAGE/gitlab-rails-ee:$rails_container${IMAGE_TAG_EXT}"
                      --build-arg "GITLAB_LOGGER_IMAGE=${CI_REGISTRY_IMAGE}/gitlab-logger:${GITLAB_LOGGER_VERSION}${IMAGE_TAG_EXT}"
    - push_tags $GITLAB_REF_SLUG${IMAGE_TAG_EXT}
  needs:
    - gitlab-rails-ee
    - gitlab-python
    - gitlab-logger
    - job: build:gitlab-webservice-ee
      optional: true
    - job: build:gitlab-python
      optional: true
    - job: build:gitlab-logger
      optional: true

gitlab-webservice-ce:
  <<: *job-base
  <<: *except-ee
  stage: phase-six
  script:
    - import_assets artifacts/ubi/gitlab-logger.tar.gz
    - ruby_version=$(cat artifacts/container_versions/gitlab-ruby_tag.txt)
    - go_version=$(cat artifacts/container_versions/gitlab-go_tag.txt)
    - logger_target_version=$(cat artifacts/container_versions/gitlab-logger_tag.txt)
    - rails_version=$(get_version gitlab-rails)
    - rails_container=$(cat artifacts/container_versions/gitlab-rails-ce_tag.txt)
    - python_version=$(cat artifacts/container_versions/gitlab-python_tag.txt)
    - export FORCE_IMAGE_BUILDS="${FORCE_IMAGE_BUILDS-${FORCE_RAILS_IMAGE_BUILDS-false}}"
    - export GITLAB_LOGGER_VERSION=($(echo -n "$go_version$logger_target_version$GITLAB_LOGGER_VERSION$CI_PIPELINE_CREATED_AT" | sha1sum))
    - export CONTAINER_VERSION=($(echo -n "$rails_container$TARGET_VERSION" | sha1sum))
    - export BASE_IMAGE="$CI_REGISTRY_IMAGE/gitlab-rails-ce:$rails_container"
    - build_if_needed --build-arg "FROM_IMAGE=$CI_REGISTRY_IMAGE/gitlab-rails-ce"
                      --build-arg "TAG=$rails_container"
                      --build-arg "PYTHON_TAG=${python_version}"
                      --build-arg "GITLAB_LOGGER_IMAGE=${CI_REGISTRY_IMAGE}/gitlab-logger:${GITLAB_LOGGER_VERSION}${IMAGE_TAG_EXT}"
    - push_tags $GITLAB_REF_SLUG
  needs:
    - gitlab-rails-ce
    - gitlab-python
    - gitlab-logger
    - job: build:gitlab-logger
      optional: true

build:gitlab-sidekiq-ee:
  <<: *build-job-base
  stage: prepare:phase-two
  needs:
    - build:gitlab-python
    - build:gitlab-ruby
  script:
    - import_assets artifacts/ubi/gitlab-python.tar.gz
    - ruby_version=$(cat artifacts/container_versions/build_gitlab-ruby_tag.txt)
    - rails_container=($(echo -n "$ruby_version$TARGET_VERSION$GITLAB_VERSION$CI_PIPELINE_CREATED_AT" | sha1sum))
    - export CONTAINER_VERSION=($(echo -n "$rails_container$TARGET_VERSION" | sha1sum))
    - build_if_needed
    - copy_assets

gitlab-sidekiq-ee:
  <<: *job-base
  <<: *only-ee
  stage: phase-six
  script:
    - import_assets artifacts/ubi/gitlab-python.tar.gz
    - import_assets artifacts/ubi/gitlab-logger.tar.gz
    - ruby_version=$(cat artifacts/container_versions/gitlab-ruby_tag.txt)
    - go_version=$(cat artifacts/container_versions/gitlab-go_tag.txt)
    - logger_target_version=$(cat artifacts/container_versions/gitlab-logger_tag.txt)
    - rails_version=$(get_version gitlab-rails)
    - rails_container=$(cat artifacts/container_versions/gitlab-rails-ee_tag.txt)
    - python_version=$(cat artifacts/container_versions/gitlab-python_tag.txt)
    - export FORCE_IMAGE_BUILDS="${FORCE_IMAGE_BUILDS-${FORCE_RAILS_IMAGE_BUILDS-false}}"
    - export GITLAB_LOGGER_VERSION=($(echo -n "$go_version$logger_target_version$GITLAB_LOGGER_VERSION$CI_PIPELINE_CREATED_AT" | sha1sum))
    - export CONTAINER_VERSION=($(echo -n "$rails_container$TARGET_VERSION" | sha1sum))
    - if [ ! "$UBI_PIPELINE" = "true" ]; then
    -   export BASE_IMAGE="$CI_REGISTRY_IMAGE/gitlab-rails-ee:$rails_container${IMAGE_TAG_EXT}"
    - fi
    - build_if_needed --build-arg "FROM_IMAGE=$CI_REGISTRY_IMAGE/gitlab-rails-ee"
                      --build-arg "TAG=$rails_container${IMAGE_TAG_EXT}"
                      --build-arg "PYTHON_TAG=${python_version}${IMAGE_TAG_EXT}"
                      --build-arg "GITLAB_VERSION=${GITLAB_VERSION}"
                      --build-arg "RAILS_IMAGE=$CI_REGISTRY_IMAGE/gitlab-rails-ee:$rails_container${IMAGE_TAG_EXT}"
                      --build-arg "GITLAB_LOGGER_IMAGE=${CI_REGISTRY_IMAGE}/gitlab-logger:${GITLAB_LOGGER_VERSION}${IMAGE_TAG_EXT}"
    - push_tags $GITLAB_REF_SLUG${IMAGE_TAG_EXT}
  needs:
    - gitlab-rails-ee
    - gitlab-python
    - gitlab-logger
    - job: build:gitlab-python
      optional: true
    - job: build:gitlab-sidekiq-ee
      optional: true
    - job: build:gitlab-logger
      optional: true

gitlab-sidekiq-ce:
  <<: *job-base
  <<: *except-ee
  stage: phase-six
  script:
    - import_assets artifacts/ubi/gitlab-logger.tar.gz
    - ruby_version=$(cat artifacts/container_versions/gitlab-ruby_tag.txt)
    - go_version=$(cat artifacts/container_versions/gitlab-go_tag.txt)
    - logger_target_version=$(cat artifacts/container_versions/gitlab-logger_tag.txt)
    - rails_version=$(get_version gitlab-rails)
    - rails_container=$(cat artifacts/container_versions/gitlab-rails-ce_tag.txt)
    - python_version=$(cat artifacts/container_versions/gitlab-python_tag.txt)
    - export FORCE_IMAGE_BUILDS="${FORCE_IMAGE_BUILDS-${FORCE_RAILS_IMAGE_BUILDS-false}}"
    - export GITLAB_LOGGER_VERSION=($(echo -n "$go_version$logger_target_version$GITLAB_LOGGER_VERSION$CI_PIPELINE_CREATED_AT" | sha1sum))
    - export CONTAINER_VERSION=($(echo -n "$rails_container$TARGET_VERSION" | sha1sum))
    - export BASE_IMAGE="$CI_REGISTRY_IMAGE/gitlab-rails-ce:$rails_container"
    - build_if_needed --build-arg "FROM_IMAGE=$CI_REGISTRY_IMAGE/gitlab-rails-ce"
                      --build-arg "PYTHON_TAG=${python_version}"
                      --build-arg "TAG=$rails_container"
                      --build-arg "GITLAB_LOGGER_IMAGE=${CI_REGISTRY_IMAGE}/gitlab-logger:${GITLAB_LOGGER_VERSION}${IMAGE_TAG_EXT}"
    - push_tags $GITLAB_REF_SLUG
  needs:
    - gitlab-rails-ce
    - gitlab-python
    - gitlab-logger

build:gitlab-exporter:
  <<: *build-job-base
  stage: prepare:phase-two
  needs:
    - build:gitlab-ruby
    - build:postgresql
  script:
    - import_assets artifacts/ubi/{gitlab-ruby,postgresql}.tar.gz
    - ruby_version=$(cat artifacts/container_versions/build_gitlab-ruby_tag.txt)
    - ruby_container=($(echo -n "$ruby_version$GITLAB_EXPORTER_VERSION" | sha1sum))
    - export CONTAINER_VERSION=($(echo -n "$ruby_container$TARGET_VERSION" | sha1sum))
    - build_if_needed
    - copy_assets

gitlab-exporter:
  <<: *job-base
  <<: *except-deps
  stage: phase-two
  script:
    - ruby_version=$(cat artifacts/container_versions/gitlab-ruby_tag.txt)
    - ruby_container=($(echo -n "$ruby_version$GITLAB_EXPORTER_VERSION" | sha1sum))
    - export CONTAINER_VERSION=($(echo -n "$ruby_container$TARGET_VERSION" | sha1sum))
    - build_if_needed --build-arg "GITLAB_EXPORTER_VERSION=$GITLAB_EXPORTER_VERSION"
                      --build-arg "FROM_IMAGE=$CI_REGISTRY_IMAGE/gitlab-ruby"
                      --build-arg "TAG=$ruby_version${IMAGE_TAG_EXT}"
                      --build-arg "RUBY_IMAGE=${CI_REGISTRY_IMAGE}/gitlab-ruby:$ruby_version${IMAGE_TAG_EXT}"
    - push_tags
    - push_tags $GITLAB_EXPORTER_VERSION${IMAGE_TAG_EXT}
  needs:
    - gitlab-ruby
    - job: build:gitlab-exporter
      optional: true

build:gitlab-mailroom:
  <<: *build-job-base
  stage: prepare:phase-two
  needs:
    - build:gitlab-ruby
  script:
    - import_assets artifacts/ubi/gitlab-ruby.tar.gz
    - export CONTAINER_VERSION=($(echo -n "$ruby_version$MAILROOM_VERSION" | sha1sum))
    - build_if_needed --build-arg "MAILROOM_VERSION=$MAILROOM_VERSION"
    - copy_assets

gitlab-mailroom:
  <<: *job-base
  <<: *except-deps
  stage: phase-two
  script:
    - ruby_version=$(cat artifacts/container_versions/gitlab-ruby_tag.txt)
    - export CONTAINER_VERSION=($(echo -n "$ruby_version$TARGET_VERSION$MAILROOM_VERSION" | sha1sum))
    - build_if_needed --build-arg "MAILROOM_VERSION=$MAILROOM_VERSION"
                      --build-arg "FROM_IMAGE=$CI_REGISTRY_IMAGE/gitlab-ruby"
                      --build-arg "TAG=$ruby_version${IMAGE_TAG_EXT}"
                      --build-arg "RUBY_IMAGE=$CI_REGISTRY_IMAGE/gitlab-ruby:$ruby_version${IMAGE_TAG_EXT}"
    - push_tags
    - push_tags $MAILROOM_VERSION${IMAGE_TAG_EXT}
  needs:
      - gitlab-ruby
      - job: build:gitlab-mailroom
        optional: true

build:gitlab-shell:
  <<: *build-job-base
  stage: prepare:phase-three
  needs:
    - build:gitlab-go
    - build:gitlab-ruby
    - build:gitlab-logger
    - build:gitlab-gomplate
  script:
    - import_assets artifacts/ubi/{gitlab-go,gitlab-ruby}.tar.gz
    - go_version=$(cat artifacts/container_versions/build_gitlab-go_tag.txt)
    - export CONTAINER_VERSION=($(echo -n "$BASE_VERSION$go_version$TARGET_VERSION$GITLAB_SHELL_VERSION$CI_PIPELINE_CREATED_AT" | sha1sum))
    - build_if_needed --build-arg "VERSION=${GITLAB_SHELL_VERSION}"
                      --build-arg "NAMESPACE=${GITLAB_NAMESPACE}"
                      --build-arg "API_URL=${CI_API_V4_URL}"
                      --build-arg "API_TOKEN=${FETCH_DEV_ARTIFACTS_PAT}"
    - copy_assets

gitlab-shell:
  <<: *job-base
  <<: *except-deps
  stage: phase-four
  script:
    - import_assets artifacts/ubi/{gitlab-logger,gitlab-gomplate}.tar.gz
    - ruby_version=$(cat artifacts/container_versions/gitlab-ruby_tag.txt)
    - go_version=$(cat artifacts/container_versions/gitlab-go_tag.txt)
    - logger_target_version=$(cat artifacts/container_versions/gitlab-logger_tag.txt)
    - gomplate_version=$(cat artifacts/container_versions/gitlab-gomplate_tag.txt)
    - export GITLAB_LOGGER_VERSION=($(echo -n "$go_version$logger_target_version$GITLAB_LOGGER_VERSION$CI_PIPELINE_CREATED_AT" | sha1sum))
    - export CONTAINER_VERSION=($(echo -n "$BASE_VERSION$go_version$gomplate_version$TARGET_VERSION$GITLAB_SHELL_VERSION$CI_PIPELINE_CREATED_AT" | sha1sum))
    - if [ ! "$UBI_PIPELINE" = "true" ]; then
    -   export BASE_IMAGE="$CI_REGISTRY_IMAGE/gitlab-go:${go_version}${IMAGE_TAG_EXT}"
    - fi
    - build_if_needed --build-arg "TAG=${go_version}${IMAGE_TAG_EXT}"
                      --build-arg "GO_TAG=${go_version}${IMAGE_TAG_EXT}"
                      --build-arg "GOMPLATE_TAG=${gomplate_version}${IMAGE_TAG_EXT}"
                      --build-arg "GITLAB_SHELL_VERSION=${GITLAB_SHELL_VERSION}"
                      --build-arg "GITLAB_NAMESPACE=${GITLAB_NAMESPACE}"
                      --build-arg "FETCH_ARTIFACTS_PAT=${FETCH_DEV_ARTIFACTS_PAT}"
                      --build-arg "CI_API_V4_URL=${CI_API_V4_URL}"
                      --build-arg "CACHE_BUSTER=$GITLAB_SHELL_VERSION$(date -uI)"
                      --build-arg "RUBY_IMAGE=${CI_REGISTRY_IMAGE}/gitlab-ruby:$ruby_version${IMAGE_TAG_EXT}"
                      --build-arg "GITLAB_LOGGER_IMAGE=${CI_REGISTRY_IMAGE}/gitlab-logger:${GITLAB_LOGGER_VERSION}${IMAGE_TAG_EXT}"
    - push_tags gitlab-$GITLAB_REF_SLUG${IMAGE_TAG_EXT}  # This can be removed during https://gitlab.com/gitlab-com/gl-infra/delivery/-/issues/1553
    - push_tags $GITLAB_SHELL_VERSION${IMAGE_TAG_EXT}
    - echo -n "${CONTAINER_VERSION}" > artifacts/container_versions/gitlab-shell_tag.txt
  needs:
    - gitlab-gomplate
    - gitlab-logger
    - job: build:gitlab-logger
      optional: true
    - job: build:gitlab-gomplate
      optional: true
    - job: build:gitlab-shell
      optional: true

build:gitlab-elasticsearch-indexer:
  <<: *build-job-base
  stage: prepare:phase-two
  needs:
    - build:gitlab-go
  script:
    - import_assets artifacts/ubi/gitlab-go.tar.gz
    - go_version=$(cat artifacts/container_versions/build_gitlab-go_tag.txt)
    - export CONTAINER_VERSION=($(echo -n "$GITLAB_ELASTICSEARCH_INDEXER_VERSION$go_version$TARGET_VERSION" | sha1sum))
    - build_if_needed --build-arg "VERSION=${GITLAB_ELASTICSEARCH_INDEXER_VERSION}"
                      --build-arg "NAMESPACE=${GITLAB_NAMESPACE}"
                      --build-arg "API_URL=${CI_API_V4_URL}"
                      --build-arg "API_TOKEN=${FETCH_DEV_ARTIFACTS_PAT}"
    - copy_assets

gitlab-elasticsearch-indexer:
  <<: *job-base
  <<: *only-ee
  stage: phase-four
  needs:
    - gitlab-go
  script:
    - go_version=$(cat artifacts/container_versions/gitlab-go_tag.txt)
    - export CONTAINER_VERSION=($(echo -n "$GITLAB_ELASTICSEARCH_INDEXER_VERSION$go_version$TARGET_VERSION" | sha1sum))
    - build_if_needed --build-arg "TAG=${go_version}${IMAGE_TAG_EXT}"
                      --build-arg "GO_TAG=${go_version}${IMAGE_TAG_EXT}"
                      --build-arg "GITLAB_NAMESPACE=${GITLAB_NAMESPACE}"
                      --build-arg "FETCH_ARTIFACTS_PAT=${FETCH_DEV_ARTIFACTS_PAT}"
                      --build-arg "CI_API_V4_URL=${CI_API_V4_URL}"
                      --build-arg "GITLAB_ELASTICSEARCH_INDEXER_VERSION=${GITLAB_ELASTICSEARCH_INDEXER_VERSION}"
    - push_tags "$GITLAB_ELASTICSEARCH_INDEXER_VERSION${IMAGE_TAG_EXT}"

build:gitaly:
  <<: *build-job-base
  stage: prepare:phase-two
  needs:
    - build:gitlab-go
    - build:gitlab-ruby
  script:
    - import_assets artifacts/ubi/{gitlab-go,gitlab-ruby}.tar.gz
    - go_version=$(cat artifacts/container_versions/build_gitlab-go_tag.txt)
    - export shell_container=($(echo -n "$BASE_VERSION$go_version$TARGET_VERSION$GITLAB_SHELL_VERSION$CI_PIPELINE_CREATED_AT" | sha1sum))
    - export CONTAINER_VERSION=($(echo -n "$shell_container$GITALY_SERVER_VERSION$go_version$TARGET_VERSION" | sha1sum))
    - build_if_needed --build-arg "VERSION=${GITALY_SERVER_VERSION}"
                      --build-arg "NAMESPACE=${GITLAB_NAMESPACE}"
                      --build-arg "API_URL=${CI_API_V4_URL}"
                      --build-arg "API_TOKEN=${FETCH_DEV_ARTIFACTS_PAT}"
    - copy_assets

gitaly:
  <<: *job-base
  <<: *except-deps
  stage: phase-four
  script:
    - import_assets artifacts/ubi/gitlab-logger.tar.gz
    - ruby_version=$(cat artifacts/container_versions/gitlab-ruby_tag.txt)
    - go_version=$(cat artifacts/container_versions/gitlab-go_tag.txt)
    - gitlab_logger_tag=$(cat artifacts/container_versions/gitlab-logger_tag.txt)
    - export GITLAB_LOGGER_TAG=($(echo -n "$go_version$gitlab_logger_tag$GITLAB_LOGGER_VERSION$CI_PIPELINE_CREATED_AT" | sha1sum))
    - export CONTAINER_VERSION=($(echo -n "$GITALY_SERVER_VERSION$ruby_version$TARGET_VERSION" | sha1sum))
    - if [ ! "$UBI_PIPELINE" = "true" ]; then
    -   export BASE_IMAGE="$CI_REGISTRY_IMAGE/gitlab-go:$go_version${IMAGE_TAG_EXT}"
    - fi
    - build_if_needed --build-arg "GITALY_SERVER_VERSION=${GITALY_SERVER_VERSION}"
                      --build-arg "TAG=${go_version}${IMAGE_TAG_EXT}"
                      --build-arg "GO_TAG=${go_version}${IMAGE_TAG_EXT}"
                      --build-arg "RUBY_TAG=$ruby_version${IMAGE_TAG_EXT}"
                      --build-arg "GITLAB_NAMESPACE=${GITLAB_NAMESPACE}"
                      --build-arg "FETCH_ARTIFACTS_PAT=${FETCH_DEV_ARTIFACTS_PAT}"
                      --build-arg "CI_API_V4_URL=${CI_API_V4_URL}"
                      --build-arg "CACHE_BUSTER=$GITALY_SERVER_VERSION$(date -uI)"
                      --build-arg "RUBY_IMAGE=${CI_REGISTRY_IMAGE}/gitlab-ruby:$ruby_version${IMAGE_TAG_EXT}"
                      --build-arg "GITLAB_LOGGER_TAG=${GITLAB_LOGGER_TAG}${IMAGE_TAG_EXT}"
    - push_tags $GITALY_SERVER_VERSION${IMAGE_TAG_EXT}
    - echo -n "${CONTAINER_VERSION}" > artifacts/container_versions/gitaly_tag.txt
  needs:
    - gitlab-ruby
    - gitlab-go
    - gitlab-logger
    - job: build:gitlab-logger
      optional: true
    - job: build:gitaly
      optional: true

build:gitlab-container-registry:
  <<: *build-job-base
  stage: prepare:phase-two
  needs:
    - build:gitlab-go
  script:
    - import_assets artifacts/ubi/gitlab-go.tar.gz
    - go_version=$(cat artifacts/container_versions/build_gitlab-go_tag.txt)
    - export CONTAINER_VERSION=($(echo -n "$GITLAB_CONTAINER_REGISTRY_VERSION$go_version$TARGET_VERSION" | sha1sum))
    - build_if_needed --build-arg "REGISTRY_VERSION=${GITLAB_CONTAINER_REGISTRY_VERSION}"
                      --build-arg "REGISTRY_NAMESPACE=gitlab-org"
    - copy_assets

gitlab-container-registry:
  <<: *job-base
  <<: *except-deps
  stage: phase-four
  script:
    - import_assets artifacts/ubi/gitlab-gomplate.tar.gz
    - go_version=$(cat artifacts/container_versions/gitlab-go_tag.txt)
    - gomplate_version=$(cat artifacts/container_versions/gitlab-gomplate_tag.txt)
    - export CONTAINER_VERSION=($(echo -n "$GITLAB_CONTAINER_REGISTRY_VERSION$go_version$gomplate_version$TARGET_VERSION" | sha1sum))
    - if [ ! "$UBI_PIPELINE" = "true" ]; then
    -   export BASE_IMAGE="$CI_REGISTRY_IMAGE/gitlab-go:$go_version${IMAGE_TAG_EXT}"
    - fi
    - build_if_needed --build-arg "GO_TAG=${go_version}${IMAGE_TAG_EXT}"
                      --build-arg "GOMPLATE_TAG=${gomplate_version}${IMAGE_TAG_EXT}"
                      --build-arg "REGISTRY_VERSION=${GITLAB_CONTAINER_REGISTRY_VERSION}"
                      --build-arg "REGISTRY_NAMESPACE=gitlab-org"
                      --build-arg "DEPENDENCY_PROXY=${DEPENDENCY_PROXY}"
    - push_tags $GITLAB_CONTAINER_REGISTRY_VERSION${IMAGE_TAG_EXT}
  needs:
    - gitlab-go
    - gitlab-gomplate
    - job: build:gitlab-container-registry
      optional: true
    - job: build:gitlab-gomplate
      optional: true

build:gitlab-workhorse-ee:
  <<: *build-job-base
  stage: prepare:phase-four
  needs:
    - build:gitlab-go
    - build:gitlab-rails-ee
  script:
    - import_assets artifacts/ubi/{gitlab-go,gitlab-rails-ee}.tar.gz
    - rails_version=$(get_version gitlab-rails)
    - ruby_version=$(cat artifacts/container_versions/build_gitlab-ruby_tag.txt)
    - go_version=$(cat artifacts/container_versions/build_gitlab-go_tag.txt)
    - rails_container=($(echo -n "$ruby_version$TARGET_VERSION$GITLAB_VERSION$CI_PIPELINE_CREATED_AT" | sha1sum))
    - export CONTAINER_VERSION=($(echo -n "$rails_container$go_version$TARGET_VERSION" | sha1sum))
    - build_if_needed --build-arg "VERSION=$GITLAB_VERSION"
                      --build-arg "NAMESPACE=${GITLAB_NAMESPACE}"
                      --build-arg "API_URL=${CI_API_V4_URL}"
                      --build-arg "API_TOKEN=${FETCH_DEV_ARTIFACTS_PAT}"
    - copy_assets

gitlab-workhorse-ee:
  <<: *job-base
  <<: *only-ee
  stage: phase-six
  script:
    - import_assets artifacts/ubi/gitlab-gomplate.tar.gz
    - rails_version=$(get_version gitlab-rails)
    - ruby_version=$(cat artifacts/container_versions/gitlab-ruby_tag.txt)
    - go_version=$(cat artifacts/container_versions/gitlab-go_tag.txt)
    - rails_container=$(cat artifacts/container_versions/gitlab-rails-ee_tag.txt)
    - gomplate_version=$(cat artifacts/container_versions/gitlab-gomplate_tag.txt)
    - export CONTAINER_VERSION=($(echo -n "$rails_container$go_version$TARGET_VERSION" | sha1sum))
    - if [ ! "$UBI_PIPELINE" = "true" ]; then
    -   export BASE_IMAGE="$CI_REGISTRY_IMAGE/gitlab-go:$go_version${IMAGE_TAG_EXT}"
    - fi
    - build_if_needed --build-arg "GO_TAG=${go_version}${IMAGE_TAG_EXT}"
                      --build-arg "GITLAB_VERSION=$GITLAB_VERSION"
                      --build-arg "RAILS_VERSION=$rails_container${IMAGE_TAG_EXT}"
                      --build-arg "RUBY_VERSION=$ruby_version${IMAGE_TAG_EXT}"
                      --build-arg "GITLAB_EDITION=gitlab-rails-ee"
                      --build-arg "RUBY_IMAGE=${CI_REGISTRY_IMAGE}/gitlab-ruby:$ruby_version${IMAGE_TAG_EXT}"
                      --build-arg "GOMPLATE_TAG=${gomplate_version}${IMAGE_TAG_EXT}"
    - push_tags $GITLAB_REF_SLUG${IMAGE_TAG_EXT}
  needs:
    - gitlab-rails-ee
    - gitlab-ruby
    - gitlab-go
    - job: build:gitlab-workhorse-ee
      optional: true
    - gitlab-gomplate
    - job: build:gitlab-gomplate
      optional: true

gitlab-workhorse-ce:
  <<: *job-base
  <<: *except-ee
  stage: phase-six
  script:
    - import_assets artifacts/ubi/gitlab-gomplate.tar.gz
    - rails_version=$(get_version gitlab-rails)
    - ruby_version=$(cat artifacts/container_versions/gitlab-ruby_tag.txt)
    - go_version=$(cat artifacts/container_versions/gitlab-go_tag.txt)
    - rails_container=$(cat artifacts/container_versions/gitlab-rails-ce_tag.txt)
    - gomplate_version=$(cat artifacts/container_versions/gitlab-gomplate_tag.txt)
    - export CONTAINER_VERSION=($(echo -n "$rails_container$go_version$TARGET_VERSION" | sha1sum))
    - export BASE_IMAGE="$CI_REGISTRY_IMAGE/gitlab-go:$go_version"
    - build_if_needed --build-arg "GO_TAG=${go_version}${IMAGE_TAG_EXT}"
                      --build-arg "GITLAB_VERSION=$GITLAB_VERSION"
                      --build-arg "RAILS_VERSION=${rails_container}"
                      --build-arg "RUBY_VERSION=$ruby_version"
                      --build-arg "GITLAB_EDITION=gitlab-rails-ce"
                      --build-arg "GOMPLATE_TAG=${gomplate_version}${IMAGE_TAG_EXT}"
    - push_tags $GITLAB_REF_SLUG
  needs:
    - gitlab-ruby
    - gitlab-go
    - gitlab-rails-ce
    - gitlab-gomplate
    - job: build:gitlab-gomplate
      optional: true


build:gitlab-kas:
  <<: *build-job-base
  stage: prepare:phase-two
  needs:
    - build:gitlab-go
  script:
    - import_assets artifacts/ubi/gitlab-go.tar.gz
    - go_version=$(cat artifacts/container_versions/build_gitlab-go_tag.txt)
    - export TARGET_VERSION=$(get_target_version)
    - export CONTAINER_VERSION=($(echo -n "$GITLAB_KAS_VERSION$go_version$TARGET_VERSION" | sha1sum))
    - build_if_needed --build-arg "GITLAB_NAMESPACE=gitlab-org"
                      --build-arg "GITLAB_KAS_VERSION=${GITLAB_KAS_VERSION}"
                      --build-arg "CI_SERVER_HOST=${CI_SERVER_HOST}"
                      --build-arg "CI_SERVER_PORT=${CI_SERVER_PORT}"
    - copy_assets

gitlab-kas:
  <<: *job-base
  <<: *except-deps
  stage: phase-four
  needs:
    - gitlab-go
    - job: build:gitlab-kas
      optional: true
  script:
    - go_version=$(cat artifacts/container_versions/gitlab-go_tag.txt)
    - export TARGET_VERSION=$(get_target_version)
    - export CONTAINER_VERSION=($(echo -n "$GITLAB_KAS_VERSION$go_version$TARGET_VERSION" | sha1sum))
    - if [ ! "$UBI_PIPELINE" = "true" ]; then
    -   export BASE_IMAGE="$CI_REGISTRY_IMAGE/gitlab-go:$go_version${IMAGE_TAG_EXT}"
    - fi
    - build_if_needed --build-arg "FROM_IMAGE=$CI_REGISTRY_IMAGE/gitlab-go"
                      --build-arg "TAG=${go_version}${IMAGE_TAG_EXT}"
                      --build-arg "GITLAB_NAMESPACE=gitlab-org"
                      --build-arg "GITLAB_KAS_VERSION=${GITLAB_KAS_VERSION}"
                      --build-arg "CI_SERVER_HOST=${CI_SERVER_HOST}"
                      --build-arg "CI_SERVER_PORT=${CI_SERVER_PORT}"
    - push_tags "$GITLAB_KAS_VERSION${IMAGE_TAG_EXT}"
    - echo -n "${CONTAINER_VERSION}" > artifacts/container_versions/gitlab-kas_tag.txt

trigger-chart-test:
  stage: final-list
  trigger:
    project: 'gitlab-org/charts/gitlab'
    branch: master-trigger-branch
  inherit:
    variables: false
  variables:
    GITLAB_VERSION: "${CI_COMMIT_REF_SLUG}"
    REVIEW_REF_PREFIX: "${CI_PIPELINE_ID}-"
  rules:
    # Run only on main .com repo branches
    - if: '$CI_COMMIT_BRANCH && $CI_PROJECT_PATH == "gitlab-org/build/CNG"'
      when: manual
      allow_failure: true
    - when: never

final-images-listing:
  <<: *job-base
  stage: final-list
  script:
    - for i in artifacts/final/* ; do echo "${i} - $(cat ${i})" ; done
  needs: !reference [.final_images]
  rules: # NOTE: never runs for auto-deploy branches. See `workflow:rules` above.
      # Don't run on deps pipelines
    - <<: *if_deps_pipeline
      when: never
      # Don't run for specific version pipelines
    - <<: *if_ce_pipeline
      when: never
    - <<: *if_ee_pipeline
      when: never
      # Don't run on tags
    - if: '$CI_COMMIT_TAG'    # Available only in pipelines for tags.
      when: never
      # Run on any Branch pipeline
    - if: '$CI_COMMIT_BRANCH' # Available in branch pipelines. Not available in MR (detached) or Tag pipelines.
      when: always
  artifacts:
    paths:
      - artifacts/final/

image-metrics:
  # intentionally not using .job-base
  stage: final-list
  image: ${DEPENDENCY_PROXY}alpine:${ALPINE_VERSION}
  script:
    - apk add skopeo jq
    - . build-scripts/metrics.sh
    - generate_image_metrics
  needs: !reference [.final_images]
  rules: # NOTE: never runs for auto-deploy branches. See `workflow:rules` above.
      # Don't run on deps pipelines
    - <<: *if_deps_pipeline
      when: never
      # Don't run for specific version pipelines
    - <<: *if_ce_pipeline
      when: never
    - <<: *if_ee_pipeline
      when: never
      # Don't run on tags
    - if: '$CI_COMMIT_TAG'    # Available only in pipelines for tags.
      when: never
      # Run on any Branch pipeline on .com (where registry is public)
      # CI_COMMIT_BRANCH is available in branch pipelines. Not available in MR (detached) or Tag pipelines.
    - if: '$CI_COMMIT_BRANCH && $CI_PROJECT_PATH == "gitlab-org/build/CNG"'
      when: always
  artifacts:
    paths:
      - artifacts/final/
    reports:
      metrics: metrics/image_metrics.txt

sync-images:
  image: "${DEPENDENCY_PROXY}docker:git"
  variables:
    DOCKER_DRIVER: overlay2
    DOCKER_HOST: tcp://docker:2375
  services:
    - docker:${DOCKER_VERSION}-dind
  stage: release
  allow_failure: false
  script:
    - cat artifacts/images/* > image_versions.txt
    - rm -rf artifacts/*
    - sh build-scripts/docker_image_sync.sh image_versions.txt
    - if $(echo $CI_COMMIT_TAG | grep -Eq 'v*-ubi8'); then
    -   apk add curl
    -   UBI_IMAGES=$(cat artifacts/cng_images.txt | xargs printf ', %s')
    -   curl -fS
          --request POST
          --form ref=master
          --form "variables[IMAGES]=${UBI_IMAGES:2}"
          --form "token=${SCANNING_TRIGGER_TOKEN}"
          "${SCANNING_TRIGGER_PIPELINE}"
    - fi
  artifacts:
    paths:
      - artifacts/
  rules:
    - if: '$CI_COMMIT_TAG && $CI_PROJECT_PATH == "gitlab/charts/components/images"'
      when: manual

container-scanning:
  stage: container-scanning
  needs: ["final-images-listing"]
  allow_failure: true
  script:
    - images=$(cat artifacts/final/* | xargs printf 'dev.gitlab.org:5005/gitlab/charts/components/images/%s,')
    - curl -fS
        --request POST
        --form ref=master
        --form "variables[IMAGES]=$images"
        --form "token=${SCANNING_TRIGGER_TOKEN}"
        https://gitlab.com/api/v4/projects/16505542/trigger/pipeline
  rules:
    - <<: *if_deps_pipeline
      when: never
    - if: '$CI_PROJECT_PATH == "gitlab/charts/components/images" && $CI_COMMIT_BRANCH == "master"'

ubi-assets-release:
  image: registry.gitlab.com/gitlab-org/gitlab-build-images:ubi-release
  stage: release
  needs:
    - build:kubectl
    - build:postgresql
    - build:gitlab-python
    - build:gitlab-ruby
    - build:gitlab-go
    - build:gitlab-logger
    - build:gitlab-gomplate
    - build:gitlab-pages
    - build:gitlab-container-registry
    - build:gitlab-mailroom
    - build:gitlab-exporter
    - build:gitlab-shell
    - build:gitaly
    - build:gitlab-elasticsearch-indexer
    - build:gitlab-workhorse-ee
    - build:gitlab-rails-ee
    - build:gitlab-toolbox-ee
    - build:gitlab-webservice-ee
    - build:gitlab-sidekiq-ee
    - build:gitlab-kas
  rules:
    - if: '$CI_COMMIT_TAG =~ /^v\d+\.\d+\.\d+(-rc\d+)?-ubi8$/ && $CI_PROJECT_PATH == "gitlab/charts/components/images"'
      when: manual
  before_script:
    - export UBI_RELEASE_TAG=${CI_COMMIT_TAG:-master}
    - export AWS_ACCESS_KEY_ID="${GPG_KEY_AWS_ACCESS_KEY_ID}"
    - export AWS_SECRET_ACCESS_KEY="${GPG_KEY_AWS_SECRET_ACCESS_KEY}"
    - aws s3 cp --quiet ${GPG_KEY_LOCATION} /tmp/private.pem
    - gpg --batch --import /tmp/private.pem
    - rm /tmp/private.pem
  script:
    - export AWS_ACCESS_KEY_ID="${UBI_ASSETS_AWS_ACCESS_KEY_ID}"
    - export AWS_SECRET_ACCESS_KEY="${UBI_ASSETS_AWS_SECRET_ACCESS_KEY}"
    - bash build-scripts/ubi-offline/assets-release.sh
    - rm -rf artifacts/*

ubi-release-for-certification:
  image: "registry.gitlab.com/gitlab-org/gitlab-omnibus-builder/ruby_docker:3.1.0"
  services:
    - docker:${DOCKER_VERSION}-dind
  rules:
    - <<: *if_ubi_tag
    - <<: *if_redhat_certification
  stage: release
  retry: 1
  allow_failure: true
  before_script:
    - docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY
    # Install skopeo
    - cd /tmp
    - apt-get -y update && apt-get -y install libgpgme11
    - curl -f -o skopeo.deb http://ftp.debian.org/debian/pool/main/s/skopeo/skopeo_1.4.1+ds1-1_amd64.deb
    - curl -f -o golang-github-containers-common.deb http://ftp.debian.org/debian/pool/main/g/golang-github-containers-common/golang-github-containers-common_0.42.1+ds1-2_all.deb
    - curl -f -o golang-github-containers-image.deb http://ftp.debian.org/debian/pool/main/g/golang-github-containers-image/golang-github-containers-image_5.15.2-2_all.deb
    - dpkg -i golang-github-containers-image.deb && dpkg -i golang-github-containers-image.deb && dpkg -i skopeo.deb
  script:
    - ruby build-scripts/redhat_certfication.rb "${CI_COMMIT_REF_NAME}"

issue-bot:
  stage: report
  image: registry.gitlab.com/gitlab-org/distribution/issue-bot:latest
  script: /issue-bot
  rules:
    # Only run when pipeline fails for the default branch for the primary project on gitlab.com
    - if: '$CI_COMMIT_REF_NAME == $CI_DEFAULT_BRANCH && $CI_SERVER_HOST == "gitlab.com" && $CI_PROJECT_PATH == "gitlab-org/build/CNG"'
      when: on_failure
